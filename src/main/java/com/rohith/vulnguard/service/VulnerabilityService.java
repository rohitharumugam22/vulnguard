package com.rohith.vulnguard.service;

import com.rohith.vulnguard.model.Asset;
import com.rohith.vulnguard.model.Vulnerability;
import com.rohith.vulnguard.model.enums.Severity;
import com.rohith.vulnguard.repository.VulnerabilityRepository;
import jakarta.persistence.EntityNotFoundException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.lang.NonNull;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Random;

@Service
@Transactional
public class VulnerabilityService {

        private static final Logger log = LoggerFactory.getLogger(VulnerabilityService.class);

        private final VulnerabilityRepository vulnRepository;
        private final AssetService assetService;
        private final RiskScoringService riskScoringService;

        public VulnerabilityService(VulnerabilityRepository vulnRepository,
                        AssetService assetService,
                        RiskScoringService riskScoringService) {
                this.vulnRepository = vulnRepository;
                this.assetService = assetService;
                this.riskScoringService = riskScoringService;
        }

        private static final List<String[]> VULN_TEMPLATES = List.of(
                        new String[] { "SQL Injection in Login Endpoint",
                                        "Unsanitised user input passed directly to SQL query allowing authentication bypass." },
                        new String[] { "Cross-Site Scripting (Reflected XSS)",
                                        "User-controlled input reflected in HTTP response without proper encoding." },
                        new String[] { "Server-Side Request Forgery (SSRF)",
                                        "Attacker can induce server to make HTTP requests to arbitrary internal resources." },
                        new String[] { "Broken Object Level Authorization",
                                        "API endpoint exposes data of other users by manipulating resource identifiers." },
                        new String[] { "Sensitive Data Exposure via Misconfigured S3 Bucket",
                                        "Publicly accessible S3 bucket exposes PII and internal configuration files." },
                        new String[] { "Remote Code Execution via Log4Shell",
                                        "JNDI injection via log4j allows arbitrary code execution. CVE-2021-44228." },
                        new String[] { "Unpatched OpenSSL Vulnerability",
                                        "OpenSSL version susceptible to buffer overflow allowing denial of service." },
                        new String[] { "JWT None Algorithm Acceptance",
                                        "Application accepts unsigned JWT tokens with alg=none, bypassing authentication." },
                        new String[] { "XML External Entity (XXE) Injection",
                                        "XML parser processes external entity references exposing local filesystem." },
                        new String[] { "Insecure Direct Object Reference (IDOR)",
                                        "Sequential numeric identifiers allow enumeration and access to other users data." },
                        new String[] { "Path Traversal in File Download",
                                        "User-supplied filename not sanitised, allowing directory traversal attacks." },
                        new String[] { "Weak TLS Configuration",
                                        "Server supports TLS 1.0/1.1 and weak cipher suites (RC4, DES)." },
                        new String[] { "Default Admin Credentials",
                                        "Management interface accessible with factory-default admin/admin credentials." },
                        new String[] { "Missing Rate Limiting on Auth Endpoint",
                                        "No rate limiting allows brute-force password attacks at high throughput." },
                        new String[] { "Prototype Pollution in npm Dependency",
                                        "Transitive dependency allows attackers to pollute JavaScript Object prototype." });

        private static final Random RNG = new Random();

        // ✅ Removed @SuppressWarnings("null") — not needed
        public List<Vulnerability> simulateScan(@NonNull Long assetId) {
                Asset asset = assetService.getById(assetId);
                log.info("Starting simulated scan for asset [{}] - {}", assetId, asset.getName());

                int count = 3 + RNG.nextInt(3);
                List<Vulnerability> discovered = new ArrayList<>();

                List<String[]> pool = new ArrayList<>(VULN_TEMPLATES);
                Collections.shuffle(pool, RNG);

                for (int i = 0; i < count; i++) {
                        String[] template = pool.get(i);
                        Severity severity = randomSeverity();
                        int ageInDays = RNG.nextInt(180) + 1;
                        double cvssScore = randomCvss(severity);

                        Vulnerability vuln = Vulnerability.builder()
                                        .cveId(generateCveId())
                                        .title(template[0])
                                        .description(template[1])
                                        .severity(severity)
                                        .cvssScore(cvssScore)
                                        .ageInDays(ageInDays)
                                        .riskScore(0.0)
                                        .remediated(false)
                                        .asset(asset)
                                        .build();

                        vuln.setRiskScore(riskScoringService.calculateScore(vuln));
                        discovered.add(vuln);
                }

                List<Vulnerability> saved = vulnRepository.saveAll(discovered);

                asset.setLastScannedAt(LocalDateTime.now());
                assetService.create(asset);

                log.info("Scan complete - {} vulnerabilities found for asset {}", saved.size(), assetId);
                return riskScoringService.scoreAndSort(saved);
        }

        public List<Vulnerability> getByAsset(@NonNull Long assetId) {
                return riskScoringService.scoreAndSort(vulnRepository.findByAssetId(assetId));
        }

        public List<Vulnerability> getBySeverity(Severity severity) {
                return vulnRepository.findBySeverity(severity);
        }

        public List<Vulnerability> getAllOpen() {
                return riskScoringService.scoreAndSort(vulnRepository.findByRemediatedFalse());
        }

        public Vulnerability getById(@NonNull Long id) {
                return vulnRepository.findById(id)
                                .orElseThrow(() -> new EntityNotFoundException("Vulnerability not found: " + id));
        }

        //  Removed @SuppressWarnings("null") — not needed
        public Vulnerability markRemediated(@NonNull Long id) {
                Vulnerability vuln = getById(id);
                vuln.setRemediated(true);
                return vulnRepository.save(vuln);
        }

        private Severity randomSeverity() {
                int roll = RNG.nextInt(100);
                if (roll < 10)
                        return Severity.CRITICAL;
                if (roll < 30)
                        return Severity.HIGH;
                if (roll < 60)
                        return Severity.MEDIUM;
                if (roll < 85)
                        return Severity.LOW;
                return Severity.INFO;
        }

        private double randomCvss(Severity severity) {
                return switch (severity) {
                        case CRITICAL -> 9.0 + RNG.nextDouble();
                        case HIGH -> 7.0 + RNG.nextDouble() * 2;
                        case MEDIUM -> 4.0 + RNG.nextDouble() * 3;
                        case LOW -> 1.0 + RNG.nextDouble() * 3;
                        case INFO -> RNG.nextDouble();
                };
        }

        private String generateCveId() {
                int year = 2022 + RNG.nextInt(3);
                int num = 10000 + RNG.nextInt(40000);
                return String.format("CVE-%d-%d", year, num);
        }
}